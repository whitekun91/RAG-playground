<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>STT¬∑Chat Chatbot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Main stylesheet for chat UI -->
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <div class="chat-box">
    <div class="chat-history" id="chatHistory"></div>
    <div class="input-row">
      <input type="text" id="chatInput" placeholder="Type your question or press the mic button!" autocomplete="off" />
      <button id="sendBtn">Send</button>
      <button id="micBtn" title="Voice Input">
        <span id="micIcon" class="mic-icon">
          <!-- Default mic SVG icon -->
          <svg class="mic-svg" width="100%" height="100%" viewBox="0 0 24 24" fill="#888" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 16a4 4 0 0 0 4-4V6a4 4 0 1 0-8 0v6a4 4 0 0 0 4 4zm5-4a1 1 0 0 1 2 0c0 4.18-3.06 7-7 7s-7-2.82-7-7a1 1 0 1 1 2 0c0 2.97 2.16 5 5 5s5-2.03 5-5zm-5 7a1 1 0 0 1 1 1v1.25a1 1 0 1 1-2 0V20a1 1 0 0 1 1-1z"/>
          </svg>
        </span>
      </button>
    </div>
    <label>
      <input type="checkbox" id="ttsToggle" />
      TTS Output (On/Off)
    </label>
  </div>

  <script>
    let mediaRecorder;
    let chunks = [];
    const chatHistory = document.getElementById('chatHistory');
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    const micBtn = document.getElementById('micBtn');
    const micIcon = document.getElementById('micIcon');
    const ttsToggle = document.getElementById('ttsToggle');

    // Function to add a message to the chat
    function addMsg(type, text, meta, imageUrls, audioUrl) {
      const wrap = document.createElement('div');
      wrap.className = 'chat-msg ' + (type === 'user' ? 'user-msg' : 'bot-msg');
      // wrap.innerHTML = `<div>${text}</div>`;
      const textDiv = document.createElement('div');
      textDiv.className = 'msg-text';
      textDiv.textContent = text;   // Keep \n as is, CSS handles line breaks
      wrap.appendChild(textDiv);

      if (meta) {
        // wrap.innerHTML += `<div class="meta">${meta}</div>`;
        const metaDiv = document.createElement('div');
        metaDiv.className = 'meta';
        metaDiv.textContent = meta;  // Meta is also handled safely
        wrap.appendChild(metaDiv);
      }
      // Display images if present
      if (Array.isArray(imageUrls) && imageUrls.length > 0) {
        const imageDiv = document.createElement('div');
        imageDiv.className = "image-container";
        imageUrls.forEach(url => {
          const img = document.createElement("img");
          img.src = url;
          imageDiv.appendChild(img);
        });
        wrap.appendChild(imageDiv);
      }
      // Play audio if present
      if (audioUrl) {
        const audio = document.createElement('audio');
        audio.src = audioUrl;
        audio.controls = true;
        audio.style.marginTop = "5px";
        wrap.appendChild(audio);
        if (ttsToggle.checked) audio.play();
      }
      chatHistory.appendChild(wrap);
      chatHistory.scrollTop = chatHistory.scrollHeight;
    }

    // Send text question
    async function sendTextQuestion() {
      const question = chatInput.value.trim();
      if (!question) return;
      addMsg('user', question, null);
      chatInput.value = "";

      addMsg('bot', '‚è≥ Generating answer...', null);

      const resp = await fetch("/ask-text", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ question, return_audio: ttsToggle.checked })
      });
      const result = await resp.json();

      // Remove previous answer (loading)
      let loadingNodes = chatHistory.querySelectorAll('.bot-msg');
      if (loadingNodes.length) {
        let last = loadingNodes[loadingNodes.length - 1];
        if (last && last.textContent.includes('‚è≥ Generating answer')) last.remove();
      }

      addMsg(
        'bot',
        result.rag_answer || "No response",
        (result.opc_command ? `OPC: ${result.opc_command}, Execution result: ${result.opc_executed ? "Success" : "Failure"}` : null),
        result.image_urls,
        result.download_url
      );
    }

    // Handle Enter key
    chatInput.addEventListener("keydown", function (e) {
      if (e.key === "Enter") {
        sendTextQuestion();
      }
    });
    sendBtn.onclick = sendTextQuestion;

    // Voice question (STT)
    micBtn.onclick = async () => {
      try {
        micBtn.disabled = true;
        // Start mic recording: change icon color/animation
        micIcon.classList.add("mic-recording");
        micIcon.querySelector('.mic-svg').setAttribute('fill', '#e44857');

        addMsg('user', 'üéôÔ∏è Recording started...', null);
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        chunks = [];

        mediaRecorder.ondataavailable = e => chunks.push(e.data);

        mediaRecorder.onstop = async () => {
          addMsg('user', '‚è≥ Recognizing speech...', null);

          // Restore mic icon
          micIcon.classList.remove("mic-recording");
          micIcon.querySelector('.mic-svg').setAttribute('fill', '#888');
          micBtn.disabled = false;

          const blob = new Blob(chunks, { type: 'audio/webm' });
          const formData = new FormData();
          formData.append("file", blob, "recorded.webm");
          formData.append("return_audio", ttsToggle.checked.toString());

          // (1) First, only get STT and display the result in chatInput
          const response = await fetch("/ask-audio-tts", {
            method: "POST",
            body: formData
          });
          const result = await response.json();

          if (result.stt_text) {
            chatInput.value = result.stt_text;
            chatInput.focus();
            addMsg('bot', `üìù Check/modify the recognized question and send.`, null);
          } else {
            addMsg('bot', "Speech recognition failed!", null);
          }
        };

        mediaRecorder.start();
        setTimeout(() => {
          if (mediaRecorder.state === "recording") mediaRecorder.stop();
        }, 9000); // 9 seconds recording limit

      } catch (err) {
        micIcon.classList.remove("mic-recording");
        micIcon.querySelector('.mic-svg').setAttribute('fill', '#888');
        addMsg('bot', '‚ö†Ô∏è Mic access failed: ' + err, null);
        micBtn.disabled = false;
      }
    };
  </script>
</body>
</html>
